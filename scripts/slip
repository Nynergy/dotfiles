#!/usr/bin/env bash

# (Sli)de (P)resenter :: 'slip'
# A script for presenting slides in the terminal

# Maintainer:       Ben Buchanan
# Version:          0.2.0
# Last Modified:    09-Mar-2024

## Present slides in the terminal
##
## Usage: $0 [OPTIONS] <FILE>
##
## Options:
##   -h, --help   Show this usage output

SCRIPT="${BASH_SOURCE[0]##*/}"

[[ -v "$XDG_CONFIG_HOME" ]] || XDG_CONFIG_HOME="$HOME/.config"

NO_FORMAT='\e[m'
BOLD='\e[1m'
ITALIC='\e[3m'
UNDERLINE='\e[4m'
HIGHLIGHT='\e[7m'

print_usage () {
    while read -r line; do
        [[ $line =~ ^##\ ?(.*)$ ]] &&
            printf '%s\n' "${BASH_REMATCH[1]/\$0/$SCRIPT}"
    done < "${BASH_SOURCE[0]}"
}

print_version () {
    while read -r line; do
        [[ $line =~ ^#\ Version:\ *(.*)$ ]] &&
            printf '%s %s\n' "$SCRIPT" "${BASH_REMATCH[1]}"
    done < "${BASH_SOURCE[0]}"
}

main () {
    process_args "$@"
    process_config
    process_input_file "$1"

    current_slide=0

    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.05)

    trap 'reset_terminal' EXIT
    trap 'get_term_size; redraw' WINCH

    get_term_size
    setup_terminal
    redraw

    # Vintage infinite loop
    for ((;;)); {
        read "${read_flags[@]}" -srn 1 && key "$REPLY"

        # Exit if there is no longer a terminal attached
        [[ -t 1 ]] || exit 1
    }
}

process_args () {
    positional_args=()

    for arg in "$@"; {
        # TODO: Arguments for turning off rendering for certain elements
        # TODO: Argument for local config file
        case $arg in
            -h|--help)
                print_usage
                exit 0
                ;;
            -v|--version)
                print_version
                exit 0
                ;;
            -*)
                arg="${arg##*-}"
                arg="${arg%%=*}"
                printf '%s: invalid option -- %s\n' "$SCRIPT" "'$arg'"
                printf 'Try %s for more information.\n' "'$SCRIPT --help'"
                exit 1
                ;;
            *)
                positional_args+=("$arg") # save positional args
                shift # past argument
                ;;
        esac
    }

    # Restore positional args
    set -- "${positional_args[@]}"

    # TODO: More robust file validation
    [[ -f "$1" ]] || {
        printf 'Please provide a valid file.\n'
        exit 1
    }
}

process_config () {
    declare -Ag config # A: Associative Array; g: Global Scope

    config=(
        # COLORS
        [BORDER_COLOR]=7
        [TITLE_COLOR]=2
        [AUTHOR_COLOR]=3
        [SLIDE_NUMBER_COLOR]=6
        [SLIDE_NUMBER_DIVIDER_COLOR]=3
        [TITLE_CARD_COLOR]=4
        [HEADER_COLOR]=2
        [LIST_TICK_COLOR]=1
        [TASK_LIST_IN_PROGRESS_COLOR]=3
        [TASK_LIST_COMPLETE_COLOR]=2
        [INLINE_CODE_COLOR]=5
        [CODE_BLOCK_STRING_COLOR]=6
        [CODE_BLOCK_NUMBER_COLOR]=6
        [CODE_BLOCK_FUNC_COLOR]=4
        [BLOCKQUOTE_COLOR]=8
        [TABLE_COLOR]=5

        # STYLES
        [BORDER_STYLE]=
        [TITLE_STYLE]='BOLD'
        [AUTHOR_STYLE]=
        [SLIDE_NUMBER_STYLE]=
        [SLIDE_NUMBER_DIVIDER_STYLE]=
        [TITLE_CARD_STYLE]='BOLD'
        [HEADER_STYLE]='BOLD,UNDERLINE'
        [LIST_TICK_STYLE]=
        [TASK_LIST_IN_PROGRESS_STYLE]='BOLD'
        [TASK_LIST_COMPLETE_STYLE]='BOLD'
        [INLINE_CODE_STYLE]=
        [CODE_BLOCK_STRING_STYLE]=
        [CODE_BLOCK_NUMBER_STYLE]=
        [CODE_BLOCK_FUNC_STYLE]=
        [BLOCKQUOTE_STYLE]='HIGHLIGHT'
        [TABLE_STYLE]=
    )

    [[ -f "$XDG_CONFIG_HOME/slip/sliprc" ]] && {
        while read -r line; do
            [[ $line =~ ^\ *([0-9a-zA-Z_]*)\ *=\ *([0-9a-zA-Z_,\ ]*)\ *$ ]] && {
                key="${BASH_REMATCH[1]^^}"
                val="${BASH_REMATCH[2]^^}"

                # Validate color numbers
                [[ $key == *COLOR ]] && validate_color_num "$val"
                # Validate style strings
                [[ $key == *STYLE ]] && validate_styles "$val"

                config[$key]=$val
            }
        done < "$XDG_CONFIG_HOME/slip/sliprc"
    }

    # Convert values into actual printable styles
    for key in "${!config[@]}"; {
        val="${config[$key]}"
        [[ -n $val && $key == *COLOR ]] && 
            config[$key]="\e[38;5;${val}m"
        [[ -n $val && $key == *STYLE ]] && {
            IFS=$' \n' read -d "" -ra styles <<< "${val//,/$'\n'}"
            combined_style=
            for style in "${styles[@]}"; {
                string_to_style "$style"
                combined_style+="\e[${converted_style_num}m"
            }
            config[$key]="$combined_style"
        }
    }
}

validate_color_num () {
    # We only allow the xterm colors 0-8
    [[ $1 =~ ^[0-8]$ ]] || {
        printf '%s is not a valid color number.\n' "'$1'"
        exit 1
    }
}

validate_styles () {
    # We only allow styles for bold, underline, italic, and highlight
    IFS=$' \n' read -d "" -ra styles <<< "${1//,/$'\n'}"
    for style in "${styles[@]}"; {
        case $style in
            BOLD|\
            UNDERLINE|\
            ITALIC|\
            HIGHLIGHT)
                ;;
            *)
                printf '%s is not a valid style.\n' "'$style'"
                exit 1
                ;;
        esac
    }
}

string_to_style () {
    case "$1" in
        BOLD)
            converted_style_num=1
            ;;
        ITALIC)
            converted_style_num=3
            ;;
        UNDERLINE)
            converted_style_num=4
            ;;
        HIGHLIGHT)
            converted_style_num=7
            ;;
        *)
            converted_style_num=
            ;;
    esac
}

process_input_file () {
    extract_slides "$1"
    extract_metadata "${slides[0]}"

    # Pop the metadata from the rest of the slides
    # We need to do this with subtitles, too
    slides=("${slides[@]:1}")
    subtitles=("${subtitles[@]:1}")

    num_slides="$((${#slides[@]} - 1))"
}

extract_slides () {
    declare -ag slides # a: Array, g: Global Scope
    declare -ag subtitles # a: Array, g: Global Scope

    slide=''
    current_subtitle=''
    IFS='' # Preserve whitespace
    while read -r line; do
        # Skip leading empty lines
        [[ -z $slide && -z $line ]] && continue

        [[ -n $slide && $line == '---' ]] && {
            slides+=("$slide")
            slide=''
            
            subtitles+=("$current_subtitle")

            continue
        }

        # h1 headers are treated as title cards
        [[ $line =~ ^#\ +.*$ ]] && {
            [[ -n $slide ]] && {
                slides+=("$slide")
                slide=''
            }

            slides+=("$line")
            slide=''

            # Title card slides themselves never have subtitles
            subtitles+=('')
            current_subtitle="${line### }"

            continue
        }

        [[ $line != '---' ]] && slide+="$line"$'\n'
    done < "$1"

    [[ -n $slide ]] && {
        slides+=("$slide")
        subtitles+=("$current_subtitle")
    }
}

extract_metadata () {
    declare -Ag metadata # A: Associative Array, g: Global Scope

    while IFS=$'\n' read -r line; do
        [[ $line =~ ^\ *(.*)\ *:\ *(.*)\ *$ ]] && {
            key="${BASH_REMATCH[1]^^}"
            val="${BASH_REMATCH[2]}"
            metadata["$key"]="$val"
        }
    done <<< "$1"

    # Verify that a title was supplied
    [[ -z "${metadata['TITLE']}" ]] && {
        printf 'Please provide a title in your presentation metadata.\n'
        exit 1
    }
}

save_cursor_position () {
    printf '\e[s'
}

restore_cursor_position () {
    printf '\e[u'
}

use_alt_screen_buffer () {
    printf '\e[?1049h'
}

use_main_screen_buffer () {
    printf '\e[?1049l'
}

disable_line_wrapping () {
    printf '\e[?7l'
}

enable_line_wrapping () {
    printf '\e[?7h'
}

hide_cursor () {
    printf '\e[?25l'
}

show_cursor () {
    printf '\e[?25h'
}

move () {
    # TODO: Our WINCH trap isn't working properly for some reason
    #       The values being passed in here are invalid numbers
    printf '\e[%d;%dH' "$1" "$2"
}

erase_up () {
    printf '\e[1J'
}

erase_all () {
    printf '\e[2J'
}

clear_screen () {
    move "$LINES" "$COLUMNS"
    erase_up
    [[ -v "$TMUX" ]] && erase_all # Fix for tmux
    move 0 0
}

set_modifiers () {
    printf '%b' "$1"
}

reset_modifiers () {
    printf '%b' "$NO_FORMAT"
}

setup_terminal () {
    save_cursor_position
    use_alt_screen_buffer
    disable_line_wrapping
    hide_cursor
    clear_screen

    # Hide echoing of user input
    stty -echo
}

reset_terminal () {
    enable_line_wrapping
    show_cursor
    clear_screen
    use_main_screen_buffer
    restore_cursor_position

    # Show user input
    stty echo
}

get_term_size () {
    read -r LINES COLUMNS < <(stty size)
}

redraw () {
    clear_screen
    slide_header
    slide_content
    slide_footer
}

slide_header () {
    move 0 0
    border_bar

    subtitle="${subtitles[$current_slide]}"
    printf -v title '%s%s' "${metadata['TITLE']}" "${subtitle:+" > $subtitle"}"
    hcenter_string "$title" 3 "${config['TITLE_COLOR']}${config['TITLE_STYLE']}"
}

border_bar () {
    printf -v hline "%${COLUMNS}s"
    printf '%b%s%b' "${config['BORDER_COLOR']}${config['BORDER_STYLE']}" "${hline// /=}" "$NO_FORMAT"
}

slide_footer () {
    move "$LINES" 0
    border_bar

    author_name
    slide_number
}

author_name () {
    author="${metadata['AUTHOR']}"

    move "$((LINES - 2))" 3
    set_modifiers "${config['AUTHOR_COLOR']}${config['AUTHOR_STYLE']}"
    printf '%s' "$author"
    reset_modifiers
}

slide_number () {
    move "$((LINES - 2))" "$((COLUMNS - 4))"
    set_modifiers "${config['SLIDE_NUMBER_COLOR']}${config['SLIDE_NUMBER_STYLE']}"
    printf '%3d' "$num_slides"
    reset_modifiers

    move "$((LINES - 2))" "$((COLUMNS - 6))"
    set_modifiers "${config['SLIDE_NUMBER_DIVIDER_COLOR']}${config['SLIDE_NUMBER_DIVIDER_STYLE']}"
    printf '/'
    reset_modifiers

    move "$((LINES - 2))" "$((COLUMNS - 10))"
    set_modifiers "${config['SLIDE_NUMBER_COLOR']}${config['SLIDE_NUMBER_STYLE']}"
    printf '%3d' "$current_slide"
    reset_modifiers
}

slide_content () {
    content="${slides[$current_slide]}"

    pos_y=5
    in_code_block=0
    while read -r line; do
        move "$pos_y" 3

        # Check for formatting opportunities
        # **BOLD** __BOLD__
        while [[ $line =~ ^(.*)(\*\*|__)(.*)(\*\*|__)(.*)$ ]]; do
            line="${BASH_REMATCH[1]}"
            line+="$BOLD${BASH_REMATCH[3]}$NO_FORMAT"
            line+="${BASH_REMATCH[5]}"
        done

        # *italic* _italic_
        while [[ $line =~ ^(.*)(\*|_)(.*)(\*|_)(.*)$ ]]; do
            line="${BASH_REMATCH[1]}"
            line+="$ITALIC${BASH_REMATCH[3]}$NO_FORMAT"
            line+="${BASH_REMATCH[5]}"
        done

        # ==Highlighted Text==
        while [[ $line =~ ^(.*)(==)(.*)(==)(.*)$ ]]; do
            line="${BASH_REMATCH[1]}"
            line+="$HIGHLIGHT${BASH_REMATCH[3]}$NO_FORMAT"
            line+="${BASH_REMATCH[5]}"
        done

        # Blockquotes (>)
        # Nested Blockquotes (>>)
        while [[ $line =~ ^(\ *)\>(.*)$ ]]; do
            printf '%s %b' "${BASH_REMATCH[1]}" "${config['BLOCKQUOTE_STYLE']}${config['BLOCKQUOTE_COLOR']} $NO_FORMAT"
            line="${BASH_REMATCH[2]}"
        done

        # Code ```blocks```
        # Toggle between code block mode when we encounter three backticks
        [[ $line == '```' ]] && {
            ((in_code_block ^= 1))
            continue
        }

        # Style things inside code blocks
        [[ $in_code_block == 1 ]] && {
            # Two different string literals
            while [[ $line =~ ^(.*)(\'.*\')(.*)$ ]]; do
                printf '%b%b%b%b' "${BASH_REMATCH[1]}" \
                                  "${config['CODE_BLOCK_STRING_COLOR']}${config['CODE_BLOCK_STRING_STYLE']}" "${BASH_REMATCH[2]}" "$NO_FORMAT"
                line="${BASH_REMATCH[3]}"
            done
            while [[ $line =~ ^(.*)(\".*\")(.*)$ ]]; do
                printf '%b%b%b%b' "${BASH_REMATCH[1]}" \
                                  "${config['CODE_BLOCK_STRING_COLOR']}${config['CODE_BLOCK_STRING_STYLE']}" "${BASH_REMATCH[2]}" "$NO_FORMAT"
                line="${BASH_REMATCH[3]}"
            done

            # Number literals
            while [[ $line =~ ^(.*[^0-9])([0-9]+)([^0-9].*)$ ]]; do
                printf '%b%b%b%b' "${BASH_REMATCH[1]}" \
                                  "${config['CODE_BLOCK_NUMBER_COLOR']}${config['CODE_BLOCK_NUMBER_STYLE']}" "${BASH_REMATCH[2]}" "$NO_FORMAT"
                line="${BASH_REMATCH[3]}"
            done

            # Generic function names
            while [[ $line =~ ^(.*\ )([a-zA-Z][0-9a-zA-Z]*)(\(\).*)$ ]]; do
                printf '%b%b%b%b' "${BASH_REMATCH[1]}" \
                                  "${config['CODE_BLOCK_FUNC_COLOR']}${config['CODE_BLOCK_FUNC_STYLE']}" "${BASH_REMATCH[2]}" "$NO_FORMAT"
                line="${BASH_REMATCH[3]}"
            done
        }

        # Inline `code`
        while [[ $line =~ ^(.*)(\`)(.*)(\`)(.*)$ ]]; do
            line="${BASH_REMATCH[1]}"
            line+="${config['INLINE_CODE_COLOR']}${config['INLINE_CODE_STYLE']}${BASH_REMATCH[3]}$NO_FORMAT"
            line+="${BASH_REMATCH[5]}"
        done

        # h1, h2, etc.
        [[ $line =~ ^#{2,6}\ +.*$ ]] &&
            line="${config['HEADER_COLOR']}${config['HEADER_STYLE']}$line$NO_FORMAT"

        # Task Lists
        [[ $line =~ ^(\ *-\ \[)([\ ~xX]|-)(\]\ +.*)$ ]] && {
            case "${BASH_REMATCH[2]}" in
                '~'|'-')
                    color="${config['TASK_LIST_IN_PROGRESS_COLOR']}${config['TASK_LIST_IN_PROGRESS_STYLE']}"
                    ;;
                'x'|'X')
                    color="${config['TASK_LIST_COMPLETE_COLOR']}${config['TASK_LIST_COMPLETE_STYLE']}"
                    ;;
                *)
                    color="$NO_FORMAT"
                    ;;
            esac
            line="${BASH_REMATCH[1]}"
            line+="$color${BASH_REMATCH[2]}$NO_FORMAT"
            line+="${BASH_REMATCH[3]}"
        }

        # Ordered & Unordered Lists
        [[ $line =~ ^(\ *)(-|\+|\*|[0-9]*\.)(\ +.*)$ ]] && {
            printf '%b%b%b%b' "${BASH_REMATCH[1]}" \
                              "${config['LIST_TICK_COLOR']}${config['LIST_TICK_STYLE']}" "${BASH_REMATCH[2]}" "$NO_FORMAT"
            line="${BASH_REMATCH[3]}"
        }

        # Tables
        # Regular rows
        [[ $line =~ ^(\ *)\|([^-]*)\|(.*)$ ]] && {
            line="${line//\|/${config['TABLE_COLOR']}${config['TABLE_STYLE']}\|$NO_FORMAT}"
        }
        # Divider rows
        [[ $line =~ ^(\ *)\|(\ *-+\ *)\|(.*)$ ]] && {
            line="${line//\|/${config['TABLE_COLOR']}${config['TABLE_STYLE']}\|$NO_FORMAT}"
            line="${line//-/${config['TABLE_COLOR']}${config['TABLE_STYLE']}-$NO_FORMAT}"
        }

        # TODO: Images (w3m-img)

        # Print title cards centered
        if [[ $line =~ ^#\ +.*$ ]]; then
            hcenter_string "${line### }" "$((LINES / 2))" "${config['TITLE_CARD_COLOR']}${config['TITLE_CARD_STYLE']}"
        else
            printf '%b' "$line"
        fi

        pos_y=$((pos_y + 1))
    done <<< "$content"
}

hcenter_string () {
    str_len="${#1}"
    pos_x=$((COLUMNS / 2 - str_len / 2))

    move "$2" "$pos_x"
    set_modifiers "$3"
    printf '%b' "$1"
    reset_modifiers
}

key () {
    # Handle special key presses
    [[ $1 == $'\e' ]] && {
        read "${read_flags[@]}" -rsn 2

        # Handle a normal escape key press
        [[ ${1}${REPLY} == $'\e\e['* ]] &&
            read "${read_flags[@]}" -rsn 1 _

        local special_key=${1}${REPLY}
    }

    case ${special_key:-$1} in
        # '\e'              :: Escape
        q|$'\e')
            exit
            ;;
        # ' '               :: Space
        # ''                :: Enter
        # '\e[C', '\e[OC'   :: Right Arrow Key
        l|' '|''|$'\e[C'|$'\e[OC')
            : $((current_slide + 1))
            current_slide=$((_ > num_slides ? current_slide : _))
            redraw
            ;;
        # '\177', '\b'      :: Backspace
        # '\e[D', '\e[OD'   :: Left Arrow Key
        h|$'\177'|$'\b'|$'\e[D'|$'\e[OD')
            : $((current_slide - 1))
            current_slide=$((_ < 0 ? current_slide : _))
            redraw
            ;;
    esac
}

main "$@"
